いいね、その構成なら Godot 4.4 で気持ちよく組めます。
下記は「最初から運用まで」見据えた**シーン設計＋Autoload（シングルトン）構成**と、**最小動く骨格コード**です。まずはこの形で“薄く”完成させ、あとから機能を肉付けしていくのがおすすめ。

---

# 全体像（役割分離）

## Autoload（Project Settings > AutoLoad）

起動時に常駐。シーン間の状態を持たせ、重い 3D を都度ロード/破棄。

* `App.gd`：エントリ・ルータ（シーン遷移、ローディング表示）
* `Auth.gd`：認証状態（JWT/ユーザー情報）・ログイン/ログアウト
* `Api.gd`：HTTP クライアント（研修API/ノートAPI呼び出し）
* `NotesStore.gd`：ローカルノートの保存/読み込み（JSON）
* `RoomClient.gd`：マルチプレイ（WebSocket）接続・RPC・チャット
* `UserPrefs.gd`：音量/言語/キー設定など ConfigFile に保存
* `UiBus.gd`：UI向けのシグナル集約（トースト、モーダル、通知）

> これで**UI・3D・ネット**の関心を分離。シーンは“表示と入力だけ”に集中できます。

---

# シーン構成（最低限の骨格）

```
/scenes
  /ui
    Login.tscn
    MainMenu.tscn
    Settings.tscn
    Achievements.tscn
    Notes.tscn            # ノート作成/一覧
    TrainingList.tscn     # 研修課題一覧
  /room
    Room3D.tscn           # 3Dコミュニティ空間（共有/個人ルーム共通）
    Player.tscn           # 自キャラ
    RemotePlayer.tscn     # 他プレイヤー表示用
```

## 各シーンのツリー例（抜粋）

### Login.tscn（2D UI）

```
Login (CanvasLayer)
└─ Panel
   ├─ LineEdit (name=username)
   ├─ LineEdit (name=password, secret)
   ├─ Button  (text="Login")
   └─ HBoxContainer
      ├─ Button (text="Google")
      └─ Button (text="Facebook")
```

### MainMenu.tscn（2D UI）

```
MainMenu (CanvasLayer)
└─ VBox
   ├─ Button ("Training")
   ├─ Button ("Notes")
   ├─ Button ("Room")
   ├─ Button ("Achievements")
   └─ Button ("Settings / Logout")
```

### TrainingList.tscn（2D UI）

```
TrainingList (CanvasLayer)
└─ Panel
   ├─ ItemList (課題一覧)
   └─ Button ("Open in Browser")
```

### Notes.tscn（2D UI）

```
Notes (CanvasLayer)
└─ HSplitContainer
   ├─ ItemList (ノート一覧)
   └─ VBox
      ├─ LineEdit (タイトル)
      ├─ TextEdit (本文)         # まずはプレーンテキスト。後でBBCode/Markdown検討
      ├─ HBoxContainer
      │  ├─ Button ("Add Image")
      │  └─ Button ("Save")
      └─ ScrollContainer (プレビュー用に RichTextLabel 追加も可)
```

### Room3D.tscn（3D）

```
Room3D (Node3D)
├─ NavigationRegion3D / NavigationMesh
├─ WorldEnvironment
├─ DirectionalLight3D
├─ PlayerSpawnPoints (Node3D)
├─ MultiplayerSpawner (for RemotePlayer)
├─ CanvasLayer (UI)
│  └─ ChatPanel (LineEdit, RichTextLabel)
└─ YSort/Static meshes, Interactable nodes (課題端末/ノート端末など)
```

### Player.tscn（3D・自キャラ）

```
Player (CharacterBody3D)
├─ CollisionShape3D
├─ MeshInstance3D (or imported glTF: Mesh+Skeleton)
├─ AnimationPlayer
└─ AnimationTree
```

> `AnimationTree` の `Tree Root=AnimationNodeStateMachine`
> States: `Idle`, `Move(BlendSpace1D: speed 0→walk→run)`, `Jump`, `Fall`, `Land`
> 入力: 実速度（`velocity.length()`）をパラメータに

---

# 重要なデータフロー

* **ログイン → MainMenu**
  `Auth.login()` 成功で `App.change_scene("res://scenes/ui/MainMenu.tscn")`
* **TrainingList**
  `Api.get_trainings()` で一覧 → 選択で `OS.shell_open(url)`（外部ブラウザ）
* **Notes**
  `NotesStore.save(note)` / `NotesStore.list()` / 画像は `user://notes/assets/` に保存
* **Room3D**
  `RoomClient.connect()` → 入室 → `Player` 生成
  入力で移動 → `RoomClient.rpc_movement(pos, rot, state)` → `RemotePlayer` へ反映
  チャットは `RoomClient.rpc_chat(msg)` を全員へ

---

# Autoload 実装スケルトン

**App.gd**

```gdscript
extends Node

var _current: Node

func _ready():
    change_scene("res://scenes/ui/Login.tscn")

func change_scene(path: String):
    if _current:
        remove_child(_current)
        _current.queue_free()
    var s = load(path).instantiate()
    add_child(s)
```

**Auth.gd**

```gdscript
extends Node
signal logged_in
signal logged_out

var jwt: String = ""
var user: Dictionary = {}

func login(name: String, password: String) -> void:
    var res = await Api.post_json("/auth/login", {"name": name, "password": password})
    if res.ok:
        jwt = res.body.jwt
        user = res.body.user
        emit_signal("logged_in")
    else:
        push_error(res.error)

func logout():
    jwt = ""
    user = {}
    emit_signal("logged_out")
```

**Api.gd**

```gdscript
extends Node
const BASE = "https://example.com/api"

func _headers() -> PackedStringArray:
    var h = ["Content-Type: application/json"]
    if Auth.jwt != "":
        h.append("Authorization: Bearer %s" % Auth.jwt)
    return h

func post_json(path: String, body: Dictionary) -> Dictionary:
    var http := HTTPRequest.new()
    add_child(http)
    var err = http.request(
        "%s%s" % [BASE, path],
        _headers(),
        HTTPClient.METHOD_POST,
        JSON.stringify(body)
    )
    var result = await http.request_completed
    http.queue_free()
    return _parse(result)

func get_json(path: String) -> Dictionary:
    var http := HTTPRequest.new()
    add_child(http)
    var err = http.request("%s%s" % [BASE, path], _headers(), HTTPClient.METHOD_GET)
    var result = await http.request_completed
    http.queue_free()
    return _parse(result)

func _parse(result) -> Dictionary:
    var _res_code = result[1]
    var _res_body = result[3]
    var obj = {}
    if _res_body and _res_body != "":
        obj = JSON.parse_string(_res_body) if JSON.is_valid(_res_body) else {}
    return {
        "ok": _res_code >= 200 and _res_code < 300,
        "code": _res_code,
        "body": obj,
        "error": obj.get("message", "http error %s" % _res_code)
    }
```

**NotesStore.gd**

```gdscript
extends Node

const DIR := "user://notes"
const FILE := "user://notes/index.json"

var notes: Array = [] # [{id, title, body, images:[] , updated_at}]

func _ready():
    DirAccess.make_dir_recursive_absolute(DIR)
    load_all()

func load_all():
    if not FileAccess.file_exists(FILE):
        notes = []
        _save()
        return
    var f = FileAccess.open(FILE, FileAccess.READ)
    notes = JSON.parse_string(f.get_as_text()) or []
    f.close()

func _save():
    var f = FileAccess.open(FILE, FileAccess.WRITE)
    f.store_string(JSON.stringify(notes, "\t"))
    f.close()

func list() -> Array:
    return notes

func save_note(note: Dictionary) -> void:
    var idx = notes.find(note, func(a,b): return a.get("id")==b.get("id"))
    if idx == -1:
        notes.append(note)
    else:
        notes[idx] = note
    _save()
```

**RoomClient.gd（WebSocket + RPC）**

```gdscript
extends Node
@onready var mp := MultiplayerAPI.new()

var url := "wss://example.com/room" # サーバ側は Godot/ENet でもOK
var connected := false

func connect_room():
    if connected: return
    var peer := WebSocketMultiplayerPeer.new()
    var err := peer.create_client(url)
    if err != OK:
        push_error("ws connect failed")
        return
    mp.multiplayer_peer = peer
    get_tree().set_multiplayer(mp)
    connected = true

# 例: 位置同期（軽量化のため適度にレート制限・補間）
@rpc("unreliable_ordered")
func sync_move(id: int, pos: Vector3, rot_y: float, state: String):
    UiBus.emit_signal("remote_move", id, pos, rot_y, state)

func send_move(id, pos, rot_y, state):
    rpc_unreliable("sync_move", id, pos, rot_y, state)

@rpc
func broadcast_chat(sender: String, msg: String):
    UiBus.emit_signal("chat_message", sender, msg)

func send_chat(msg: String):
    rpc("broadcast_chat", Auth.user.get("name",""), msg)
```

**UserPrefs.gd**

```gdscript
extends Node
const CFG := "user://prefs.cfg"
var volume_sfx := 0.8
var volume_bgm := 0.6
var lang := "ja"

func load_prefs():
    var c := ConfigFile.new()
    if c.load(CFG) == OK:
        volume_sfx = c.get_value("audio","sfx", volume_sfx)
        volume_bgm = c.get_value("audio","bgm", volume_bgm)
        lang = c.get_value("ui", "lang", lang)

func save_prefs():
    var c := ConfigFile.new()
    c.set_value("audio","sfx", volume_sfx)
    c.set_value("audio","bgm", volume_bgm)
    c.set_value("ui", "lang", lang)
    c.save(CFG)
```

---

# 典型フローの最小コード

**Login.gd**

```gdscript
extends CanvasLayer
@onready var username = %username
@onready var password = %password

func _ready():
    Auth.logged_in.connect(_on_logged_in)

func _on_logged_in():
    App.change_scene("res://scenes/ui/MainMenu.tscn")

func _on_Login_button_pressed():
    Auth.login(username.text, password.text)

func _on_Google_button_pressed():
    OS.shell_open("https://example.com/oauth/google")
```

**TrainingList.gd**

```gdscript
extends CanvasLayer
@onready var list := %ItemList

func _ready():
    var res = await Api.get_json("/trainings")
    if res.ok:
        for t in res.body:
            list.add_item("%s  [%s]" % [t.title, t.progress])
        list.set_meta("data", res.body)

func _on_Open_in_Browser_pressed():
    var data: Array = list.get_meta("data")
    var idx = list.get_selected_items()
    if idx.size() == 0: return
    var url = data[idx[0]].url
    OS.shell_open(url) # 外部ブラウザで開く
```

**Notes.gd（超最小）**

```gdscript
extends CanvasLayer
@onready var titles := %ItemList
@onready var title := %LineEdit
@onready var body := %TextEdit

var current_id := ""

func _ready():
    _refresh()

func _refresh():
    titles.clear()
    for n in NotesStore.list():
        titles.add_item(n.title)

func _on_titles_item_selected(index):
    var n = NotesStore.list()[index]
    current_id = n.id
    title.text = n.title
    body.text = n.body

func _on_Save_pressed():
    if current_id == "":
        current_id = str(Time.get_unix_time_from_system())
    var note = {
        "id": current_id,
        "title": title.text,
        "body": body.text,
        "images": [],
        "updated_at": Time.get_datetime_string_from_system()
    }
    NotesStore.save_note(note)
    _refresh()
```

**Room3D.gd（入室・チャット・同期の骨格）**

```gdscript
extends Node3D

@onready var chat_input := %ChatPanel/LineEdit
@onready var chat_log := %ChatPanel/RichTextLabel
var my_id := randi()

func _ready():
    RoomClient.connect_room()
    UiBus.connect("chat_message", _on_chat)
    UiBus.connect("remote_move", _on_remote_move)
    _spawn_player()

func _process(delta):
    _update_my_move(delta) # 入力→移動→RoomClient.send_move(...)

func _on_chat(sender, msg):
    chat_log.append_text("[b]%s[/b]: %s\n" % [sender, msg])

func _on_remote_move(id, pos, rot_y, state):
    # id に該当する RemotePlayer を更新（なければ生成）

func _on_chat_entered(new_text):
    if new_text.strip_edges() == "": return
    RoomClient.send_chat(new_text)
    chat_input.clear()

func _spawn_player():
    var p = load("res://scenes/room/Player.tscn").instantiate()
    add_child(p)
    p.global_position = $PlayerSpawnPoints.get_child(0).global_position
```

---

# 入力マップ（最小）

Project Settings > Input Map

* `move_forward/back/left/right`（W/S/A/D）
* `jump`
* `sprint`
* `ui_accept`, `ui_cancel`

---

# アニメーション連動（概念）

* `speed = velocity.length()` を `AnimationTree` のパラメータへ set
* 速度 0→`Idle`、歩行範囲→`Move` 内の BlendSpace1D（0=walk, max=run）
* 垂直速度や接地判定で `Jump` / `Fall` / `Land` 遷移

---

# 2D 設定画面 × 3D 併用のコツ

* **3D優先**表示で UI が見えない → `CanvasLayer` を**シーン直下**に置く
  （3Dノードの子にしない／カメラの前に面を置かない）
* UI は**別シーン**にして `Room3D` にインスタンス。Z-order 競合回避。

---

# 最初の“完成”までのチェックリスト（順序）

1. Autoload を登録（`App, Auth, Api, NotesStore, RoomClient, UserPrefs, UiBus`）
2. `Login → MainMenu` 遷移
3. `TrainingList` で `OS.shell_open(url)` が動く
4. `Notes` でローカル保存（`user://notes/index.json`）
5. `Room3D` に入室→自キャラ移動（アニメは後回しでOK）
6. WebSocket 接続→チャットが全員に届く
7. 設定保存（音量/言語）→再起動後も反映
8. 実績/進行は**ダミー**で統計だけ表示し、後で API に繋ぐ

---

# 次の一歩（拡張ポイント）

* ノート：画像添付は `FileDialog` で `res://`→`user://notes/assets/` にコピー、本文には `img:[path]` の簡易タグ（後で BBCode/Markdown）。
* ルーム：**個人/共有**はサーバ側ルームIDで分離。`/room/:id` に接続。
* 移動同期：補間（前回座標→現在座標を `lerp`）、送信は 10〜20Hz、受信は `unreliable_ordered`。
* 認証：Godot 側は JWT 保持のみ。失効時は `Auth.logout()` → `Login` へ。
* アニメーション：`StateMachine` と `BlendSpace1D` を最初から入れておくと後で差し替えが楽。

---

この設計で「薄く」一周回すと、以後は**Room/Notes/Training**それぞれを独立に強化できます。
必要なら、どのシーンの**完全版テンプレート**（`*.tscn + *.gd` 一式）も用意します。どこから実装を始めますか？（例：Login→Menu→Notes の順で“触れる成果”を早めに出すのがおすすめ）
