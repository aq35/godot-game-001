わかる。3Dだと**真正面/左右**だけじゃなくて、\*\*斜め（任意方向）\*\*を向きますよね。
マルチで“相手の向き＋歩きアニメ”を自然に見せるには、**位置だけでなく向きも同期**します。

---

## 送る情報（MVP）

* 位置：`x, y, z`
* 向き：**yaw 角**（水平回転）だけで十分なことが多い

  * さらに精密にしたいなら **クォータニオン (x,y,z,w)** を送る
* 移動速度 or 状態：`speed`（0＝Idle、>0＝Walk/Run）や `state:"idle|walk|run"`

例（WSのペイロード）：

```json
{
  "type": "move",
  "roomId": "lobby",
  "userId": "alice",
  "pos": [12.3, 0.0, -5.1],
  "yaw": 1.57,            // ラジアン（= 約90°）
  "speed": 2.1            // ブレンド用
}
```

---

## 送信側（自分）の計算例（Godot 4）

```gdscript
# 自キャラの現在向き（水平のみ）を算出して送る例
var forward := Vector3(velocity.x, 0.0, velocity.z)
var yaw := global_transform.basis.get_euler().y
if forward.length() > 0.001:
    yaw = atan2(-forward.x, -forward.z) # Z-前方カメラの一般例

Net.send_json({
    "type":"move",
    "roomId": RoomStore.current_room_id,
    "userId": AuthStore.user_id,
    "pos":[global_position.x, global_position.y, global_position.z],
    "yaw": yaw,
    "speed": forward.length()
})
```

> ※ TPS/FPS でカメラ基準なら「カメラのヨー」を使う手もあります。

---

## 受信側（相手の見え方）

**位置は lerp、向きは slerp** でなめらかに。

```gdscript
# RemotePlayer.gd (CharacterBody3D)
@onready var anim_tree: AnimationTree = $AnimationTree

var target_pos: Vector3
var target_yaw: float = 0.0
var speed_remote := 0.0

func _process(delta):
    # 位置補間
    global_position = global_position.lerp(target_pos, delta * 10.0)

    # 向き補間（ヨーのみ）
    var cur := global_transform.basis.get_euler().y
    var new_yaw := lerp_angle(cur, target_yaw, delta * 10.0)
    var e := global_transform.basis.get_euler()
    e.y = new_yaw
    global_transform.basis = Basis.from_euler(e)

    # アニメブレンド（速度で）
    # 例: BlendSpace1D の "speed" パラメータ
    anim_tree.set("parameters/Locomotion/blend_position", clamp(speed_remote, 0.0, 4.0))
```

**メッセージ反映：**

```gdscript
func on_ws_move(msg: Dictionary):
    var p := msg.pos
    target_pos = Vector3(p[0], p[1], p[2])
    target_yaw = float(msg.yaw)
    speed_remote = float(msg.speed)
```

---

## クォータニオンでやる場合（ピッチ/ロールも必要なら）

送信：

```gdscript
var q := global_transform.basis.get_quaternion()
Net.send_json({"type":"move", "pos":[...], "rot":[q.x, q.y, q.z, q.w], "speed": speed})
```

受信：

```gdscript
var q := Quaternion(msg.rot[0], msg.rot[1], msg.rot[2], msg.rot[3])
var cur_q := global_transform.basis.get_quaternion()
var new_q := cur_q.slerp(q, delta * 10.0)
global_transform.basis = Basis(new_q)
```

---

## アニメーション設計のコツ

* **BlendSpace1D**：`speed` で Idle↔Walk↔Run を連続ブレンド（おすすめ）
* **StateMachine**：状態（idle/walk/run）を切替 → 方向は**見た目の回転で表現**
* 斜め移動の脚運びをキレイにしたいなら **Strafe（左右移動）用クリップ**を用意し、BlendSpace2D（前後×左右）もアリ

---

## ネットワーク注意点

* 送信は **10〜15Hz** 程度（高すぎると帯域/負荷が増える）
* 受信側は補間で 60fps 表示
* サーバは最後の `pos/yaw` を保持して、後入りに初期状態返却
* **不正位置**はサーバ側でクリップ（壁抜け対策の第一歩）

---

### まとめ

* **位置＋向き（yaw or quaternion）＋速度** を送れば、斜め向きや滑らかな歩き表示が実現できる
* 受信側は **lerp/slerp** と **BlendSpace** で自然に見せる

必要なら、あなたの現在の `AnimationTree` 構成（パス名）に合わせた**実コード**まで合わせ込みます。
