できる！おすすめは **Autoload の `App.gd` を「ルータ（シーン管理者）」にする**方式。
これで「どの画面からでも同じAPIで遷移」「フェード演出・非同期ロード・戻る（スタック）」を一元管理できます。

---

# 最小ルータ（置き換え遷移）

`Project Settings > AutoLoad` に `App.gd` を登録しておく前提。

```gdscript
# res://autoload/App.gd
extends Node

var current: Node
var current_path := ""
var _transition_layer: CanvasLayer   # 黒フェード用（任意）

func _ready():
    # 最初のシーンへ
    go("res://scenes/ui/Login.tscn")

func go(path: String, args: Dictionary = {}):
    await _fade_out()
    # 旧を破棄
    if current:
        remove_child(current)
        current.queue_free()
    # 新を生成
    var packed := load(path) as PackedScene
    var s := packed.instantiate()
    current = s
    current_path = path
    add_child(s)
    # 引数を渡したい場合（on_enterの約束にする）
    if s.has_method("on_enter"):
        s.call_deferred("on_enter", args)
    await _fade_in()

# フェード（任意：CanvasLayer に ColorRect を1枚置くだけ）
func _fade_out():
    if !_transition_layer: return
    var r := _transition_layer.get_node("Fade") as ColorRect
    r.show()
    # アニメ or Tween でα上げる（省略）

func _fade_in():
    if !_transition_layer: return
    var r := _transition_layer.get_node("Fade") as ColorRect
    # アニメ or Tween でα下げる（省略）
    r.hide()
```

使い方（どのシーンからでも）：

```gdscript
App.go("res://scenes/ui/MainMenu.tscn")
App.go("res://scenes/room/Room3D.tscn", {"room_id": "shared-001"})
```

---

# 戻る機能つき（スタック管理）

```gdscript
# App.gd（拡張）
var stack: Array[Dictionary] = []  # [{path, args}]

func push(path: String, args: Dictionary = {}):
    if current_path != "":
        stack.append({"path": current_path, "args": {}}) # 必要なら現在の引数を保存
    await go(path, args)

func back():
    if stack.is_empty(): return
    var prev = stack.pop_back()
    await go(prev.path, prev.args)
```

使い方：

```gdscript
App.push("res://scenes/ui/Notes.tscn") # メニュー → ノート へ
App.back()                              # ノート → メニュー に戻る
```

---

# 非同期ロード（重い3Dでもカクつかない）

```gdscript
func go_async(path: String, args: Dictionary = {}):
    await _fade_out()
    if current:
        remove_child(current)
        current.queue_free()

    # ローディング画面を先に出す
    var loading := load("res://scenes/ui/Loading.tscn").instantiate()
    add_child(loading)
    await get_tree().process_frame

    # 非同期プリロード
    var loader := ResourceLoader.load_threaded_request(path)
    while ResourceLoader.load_threaded_get_status(path) == ResourceLoader.THREAD_LOAD_IN_PROGRESS:
        await get_tree().process_frame()

    var res := ResourceLoader.load_threaded_get(path) as PackedScene
    loading.queue_free()

    current = res.instantiate()
    current_path = path
    add_child(current)
    if current.has_method("on_enter"):
        current.call_deferred("on_enter", args)
    await _fade_in()
```

---

# オーバーレイ（モーダル/ダイアログ）も一元管理

「遷移」ではなく上に被せたいとき用。

```gdscript
# App.gd
var overlay_layer: CanvasLayer

func show_modal(packed: PackedScene, args: Dictionary = {}):
    var m := packed.instantiate()
    overlay_layer.add_child(m)
    if m.has_method("on_open"):
        m.call_deferred("on_open", args)

func close_modal(node: Node):
    node.queue_free()
```

使い方：

```gdscript
App.show_modal(load("res://scenes/ui/ConfirmDialog.tscn"), {"text":"削除しますか？"})
```

---

# シーン側：パラメータを受け取る約束

遷移先シーンで任意実装：

```gdscript
# 例: Room3D.gd
var room_id := "default"

func on_enter(args: Dictionary):
    room_id = args.get("room_id", "default")
    # ここで入室処理など
```

---

# ルーティング表（名前付きルート）

ハードコードのパスを避けたい場合：

```gdscript
# App.gd
const ROUTES := {
    "login": "res://scenes/ui/Login.tscn",
    "menu": "res://scenes/ui/MainMenu.tscn",
    "notes": "res://scenes/ui/Notes.tscn",
    "room": "res://scenes/room/Room3D.tscn",
}

func goto(name: String, args: Dictionary = {}):
    var p = ROUTES.get(name, "")
    if p == "": push_error("route not found: %s" % name); return
    await go(p, args)
```

使い方：

```gdscript
App.goto("room", {"room_id": "private-42"})
```

---

# キャッシュ（同シーンを再利用したい場合）

通常は毎回 `instantiate()` でOKですが、頻繁に行き来する一覧等は保持したいことがあります。

```gdscript
var cache := {}

func go_cached(path: String, args: Dictionary = {}):
    await _fade_out()
    if current:
        current.hide()
    if !cache.has(path):
        cache[path] = load(path).instantiate()
        add_child(cache[path])
    current = cache[path]
    current_path = path
    current.show()
    if current.has_method("on_enter"):
        current.call_deferred("on_enter", args)
    await _fade_in()
```

---

# エラーハンドリング（壊れにくく）

* `load()` が null なら **ルート名・パス** をログ出力し、**安全なデフォルト画面**に戻す
* 例外的に失敗したら `App.goto("menu")` へ退避
* フェード中の重複入力を防ぐために **遷移中フラグ** を持つ

```gdscript
var busy := false
func go(path, args = {}):
    if busy: return
    busy = true
    # …処理…
    busy = false
```

---

# まとめ

* **`App.gd` に集約**：`go / push / back / show_modal / go_async` を用意
* **引数は `on_enter(args)` 約束**で受け取り
* **フェード・ローディング・非同期ロード**もここで吸収
* **スタック管理**で「戻る」も統一

必要なら、あなたの今のプロジェクト構成に合わせて `App.gd` の完成版（フェード演出用 `ColorRect` 付き）を渡すよ。
今使っているシーンの**実ファイルパス**（Login/Menu/Roomなど）を教えてくれたら、そのまま差し替え可能な形に整える！
