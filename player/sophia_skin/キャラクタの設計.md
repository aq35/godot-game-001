了解。1行ずつ（または意味のかたまりごと）で「何をしているか／なぜその書き方か」を解説し、その後に「他キャラに展開するなら」の設計指針とサンプルも出します。

---

# 行ごとの詳解（What / Why）

```gdscript
class_name SophiaSkin extends Node3D
```

* **What**: このスクリプトを `SophiaSkin` というクラス名で登録。シーン内で「ノードを追加 → SophiaSkin」で直接置ける。
* **Why**: 再利用・検索性向上。複数キャラを作るときにも型として扱えて、補完も効く。

```gdscript
@onready var animation_tree = %AnimationTree
```

* **What**: 子ノード `AnimationTree` を、ノードツリーができあがった後（\_ready到達時）に取得。
* **Why**: `%` は「名前で子を取る」Godot 4 の糖衣。パス変更に強く、`$Path` より壊れにくい（名前が一致すればOK）。

```gdscript
@onready var state_machine : AnimationNodeStateMachinePlayback = animation_tree.get("parameters/StateMachine/playback")
```

* **What**: AnimationTree のステートマシンの再生コントローラ（Playback）を取る。
* **Why**: ステート遷移を `travel("StateName")` で行うために必要。パラメータパスを文字列で持つのは AnimationTree の仕様（インスペクタと同じパス）。

```gdscript
@onready var move_tilt_path : String = "parameters/StateMachine/Move/tilt/add_amount"
```

* **What**: 走行中の「傾き（tilt）」に相当するアニメツリー・パラメータのパスを定数化。
* **Why**: マジックストリングを一箇所に集約。後でツリー構成を変えてもここだけ直せばよい。

```gdscript
var run_tilt = 0.0 : set = _set_run_tilt
```

* **What**: `run_tilt` の代入をフックして、値をクランプ＆アニメツリーに反映させる。
* **Why**: 「見かけの変数＝UI/他コードの入口」「実際の反映は常に一箇所」でバグを減らす。監視付きプロパティは Godot でよく使うパターン。

```gdscript
@export var blink = true : set = set_blink
```

* **What**: まばたきON/OFFをエクスポート。インスペクタで切り替え可能＋セット時の副作用を `set_blink` に集約。
* **Why**: デザイナブルにする（ノーコード調整）。ON/OFF時にタイマー停止などの片付けが必要なので setter に封じ込め。

```gdscript
@onready var blink_timer = %BlinkTimer
@onready var closed_eyes_timer = %ClosedEyesTimer
```

* **What**: まばたき用の2タイマーを取得。`BlinkTimer` は「次に瞬くまでの待ち時間」、`ClosedEyesTimer` は「閉眼時間」。
* **Why**: `Timer` ノードに任せると、`_process` にポーリングを書かずに済む＝シンプルで低負荷。

```gdscript
@onready var eye_mat = $sophia/rig/Skeleton3D/Sophia.get("surface_material_override/2")
```

* **What**: 目のマテリアル（おそらく MeshInstance3D の2番目のスロット）を取得。
* **Why**: マテリアルの `uv1_offset` を切り替えて「閉じ目/開き目」を表現するため。
  ※ **注意**: 共有マテリアルだと全インスタンスに波及するので、**Make Unique**（ユニーク化）推奨。

```gdscript
func _ready():
```

* **What**: ノード準備完了時に呼ばれる初期化。

```gdscript
	blink_timer.connect("timeout", func():
		eye_mat.set("uv1_offset", Vector3(0.0, 0.5, 0.0))
		closed_eyes_timer.start(0.2)
		)
```

* **What**: 点滅タイマー発火 → 目を閉じる（UVオフセットを閉眼位置へ）→ 「閉じている時間」のタイマー起動。
* **Why**: 無名関数（ラムダ）で軽く書ける。閉眼の表現をマテリアル側で完結できると、アニメーションクリップを増やさずに済む。

```gdscript
	closed_eyes_timer.connect("timeout", func():
		eye_mat.set("uv1_offset", Vector3.ZERO)
		blink_timer.start(randf_range(1.0, 4.0))
		)
```

* **What**: 閉眼タイマー発火 → 目を開ける → 次のまばたきまでをランダム間隔で予約。
* **Why**: 人間らしいランダム性。固定間隔より自然。`randf_range` は Godot 4 で標準化。

```gdscript
func set_blink(state : bool):
	if blink == state: return
	blink = state
	if blink:
		blink_timer.start(0.2)
	else:
		blink_timer.stop()
		closed_eyes_timer.stop()
```

* **What**: まばたきの有効/無効を切り替え、タイマーを開始/停止。
* **Why**: 状態遷移の副作用はここに集中。途中でOFFにしたら確実に閉眼タイマーも止める＝予期しない「閉じっぱなし」防止。

```gdscript
func _set_run_tilt(value : float):
	run_tilt = clamp(value, -1.0, 1.0)
	animation_tree.set(move_tilt_path, run_tilt)
```

* **What**: `run_tilt` を \[-1, 1] に制限し、アニメツリーに反映。
* **Why**: 入力の上限下限をここで保証して、ツリー側のブレンド暴発を防ぐ。UIや移動ロジックは範囲意識不要になる。

```gdscript
func idle():
	state_machine.travel("Idle")
```

以下同様に…

```gdscript
func move():       state_machine.travel("Move")
func fall():       state_machine.travel("Fall")
func jump():       state_machine.travel("Jump")
func edge_grab():  state_machine.travel("EdgeGrab")
func wall_slide(): state_machine.travel("WallSlide")
```

* **What**: ステートマシンの状態を明示関数で切り替え。
* **Why**: 直接 `"StateName"` を各所で書かないための薄いAPI。呼ぶ側から見て意図が明確・保守が楽。
  ※ ステート名は AnimationTree のノード名と一致している必要あり。

---

# 改善の余地（任意）

* **型注釈をもう少し付ける**：
  `@onready var animation_tree: AnimationTree = %AnimationTree`、`blink_timer: Timer` など。補完とエラー早期発見に効く。
* **範囲指定のエクスポート**：
  `@export_range(-1.0, 1.0, 0.01) var run_tilt := 0.0 : set = _set_run_tilt`
  エディタからも安全に編集可。
* **マテリアルのユニーク化**：
  目のマテリアルは**必ずユニーク化**（シーンインスタンスごとに個別の表情制御ができる）。
* **パスの集中管理**：
  パラメータパスやステート名は `const` にまとめても良い（スペルミス対策）。

---

# 他キャラクターに展開するなら（設計指針）

**狙い**：共通ロジック（まばたき・ステート遷移・傾き反映）を**基底クラス**に、ノード名やパラメータパスの**違いだけを外から注入**できるようにする。

## 1) 共通ベース `CharacterSkin.gd`

```gdscript
# res://skins/CharacterSkin.gd
class_name CharacterSkin
extends Node3D

@export var blink := true : set = set_blink
@export var animtree_path: NodePath = ^"AnimationTree"
@export var tilt_param_path := "parameters/StateMachine/Move/tilt/add_amount"
@export var eye_material_slot := 2
@export var eye_mesh_path: NodePath  # 例: ^"sophia/rig/Skeleton3D/Sophia"

@onready var animation_tree: AnimationTree = get_node(animtree_path)
@onready var playback: AnimationNodeStateMachinePlayback = animation_tree.get("parameters/StateMachine/playback")
@onready var blink_timer: Timer = %BlinkTimer
@onready var closed_eyes_timer: Timer = %ClosedEyesTimer
@onready var eye_mat := get_node(eye_mesh_path).get("surface_material_override/%d" % eye_material_slot)

var run_tilt := 0.0 : set = set_run_tilt

func _ready() -> void:
	# まばたき配線
	blink_timer.timeout.connect(func():
		eye_mat.set("uv1_offset", Vector3(0.0, 0.5, 0.0))
		closed_eyes_timer.start(0.2)
	)
	closed_eyes_timer.timeout.connect(func():
		eye_mat.set("uv1_offset", Vector3.ZERO)
		blink_timer.start(randf_range(1.0, 4.0))
	)
	if blink:
		blink_timer.start(randf_range(0.5, 1.5))

func set_blink(v: bool) -> void:
	if blink == v: return
	blink = v
	if v:
		blink_timer.start(0.2)
	else:
		blink_timer.stop()
		closed_eyes_timer.stop()

func set_run_tilt(v: float) -> void:
	run_tilt = clamp(v, -1.0, 1.0)
	animation_tree.set(tilt_param_path, run_tilt)

# 状態API（必要に応じて増やす）
func travel(state: String) -> void:
	playback.travel(state)

func idle():       travel("Idle")
func move():       travel("Move")
func fall():       travel("Fall")
func jump():       travel("Jump")
func edge_grab():  travel("EdgeGrab")
func wall_slide(): travel("WallSlide")
```

## 2) Sophia 専用派生 `SophiaSkin.gd`

```gdscript
# res://skins/SophiaSkin.gd
class_name SophiaSkin
extends CharacterSkin

@export var sophia_eye_mesh: NodePath = ^"sophia/rig/Skeleton3D/Sophia"

func _ready() -> void:
	# ベースに Sophia 固有のパスを渡す
	eye_mesh_path = sophia_eye_mesh
	animtree_path = ^"AnimationTree"
	tilt_param_path = "parameters/StateMachine/Move/tilt/add_amount"
	eye_material_slot = 2
	# 先に値を詰めた上で親の _ready を呼ぶ
	super._ready()
```

## 3) 別キャラ（例：Noah）の派生

* モデルの階層構造・マテリアルスロット番号が違っても、**エクスポートされた NodePath/スロット番号を差し替えるだけ**で流用可。
* アニメのステート名が違うなら、ベースの `idle/move/...` をオーバーライドして `travel("NoahMove")` に変えるだけ。

---

# 実運用のコツ

* **命名の標準化**：`AnimationTree` ノード名、ステート名（Idle/Move/Jump…）を**全キャラで揃える**と派生のコードがほぼ不要になる。
* **表情の実装方針を統一**：

  * テクスチャの UV オフセットで閉眼 → マテリアルの共有に注意（Make Unique）。
  * 代替案：**ShaderMaterial のパラメータ**（`blink_amount`）をアニメやスクリプトで駆動。シェーダで上下まぶたをマスクする方法はスロット依存が減る。
* **データ駆動**：`BlinkConfig.tres`（min/max間隔、閉眼時間、オフセット量など）をリソース化して `@export var blink_config: BlinkConfig` にすると、**キャラごとの調整**が楽。
* **安全策**：`get_node()` は存在チェック or エディタ時に `@tool` で検証。運用で壊れやすいのは「パス」「スロット番号」「ステート名」。

---

必要なら、ベース/派生の最小シーン構成（ノードツリー図）や ShaderMaterial 版のまばたき実装も用意します。どこまで共通化したいか（完全共通 or 7割共通）に合わせてサンプルを詰めます。
